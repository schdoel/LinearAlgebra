# -*- coding: utf-8 -*-
"""Linear Algebra - hw3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yEFLdNBaOCCI-1z19zvi4Mz-X9BnT1tW
"""

import numpy as np
import matplotlib.image as img
import matplotlib.pyplot as plt
import math

# Mount your google drive to save your gif result.
from google.colab import drive
drive.mount('/content/drive')

# QUESTION 4
# you cannot use x to compute the center and the radius inside this function.
def dataSampling(x):
    chosen=[]

    l = len(x)
    chosen.append(x[0])
    for i in range(1,15):
        chosen.append(x[int(l/15*i)])
    return chosen

#QUESTION 5
def dataSamplingVoronoi(x):
    points = np.array(x)
    from scipy.spatial import Voronoi, voronoi_plot_2d
    vor = Voronoi(points)
    vor.vertices

    return vor.vertices

def circle(sp) :
    n=len(sp)
    A = np.zeros((n, 3))
    b = np.zeros((n))
    for i in range(n):
        pt = sp[i]
        A[i, :] = [2.*pt[0], 2.*pt[1], 1]
        b[i] = pt[0]*pt[0]+pt[1]*pt[1]
    return A, b

def draw_circle(x, h, w) :
    center = [x[0], x[1]]
    radius = math.sqrt(x[2]+x[0]*x[0]+x[1]*x[1])

    x_axis = np.linspace(0, w, 700)
    y_axis = np.linspace(0, h, 700)

    a, b = np.meshgrid(x_axis, y_axis)

    C = (a - x[0])*(a - x[0]) + (b - x[1])*(b - x[1]) - radius*radius
    return a, b, C

#QUESTION 2
def normal_eq(A,b):
    AT = A.T
    AT_A = np.dot(AT,A)
    AT_A_inv = np.linalg.inv(AT_A)
    AT_b = np.dot(AT,b)
    x = np.dot(AT_A_inv,AT_b)

    r_x = b - np.dot(A,x)
    r = 0
    for i in range(len(r_x)):
      r += r_x[i]*r_x[i]
    rank = np.linalg.matrix_rank(A)
    
    return x,r,rank

#QUESTION 3
def ellipse(sp) :
    n=len(sp)
    # TODO: How many variable should use?
    A = np.zeros((n, 5))
    b = np.ones((n))
    for i in range(n):
        pt = sp[i]
        x = pt[0]
        y = pt[1]
        # TODO: ellipse formula here.
        A[i, :] = [x*x, x*y, y*y, x, y]
        b[i] = 1

    return A, b

def draw_ellipse(x, h, w) :
    # plot the drawing and the fitted circle
    x_axis = np.linspace(0, w, 700)
    y_axis = np.linspace(0, h, 700)

    a, b = np.meshgrid(x_axis, y_axis)

    # TODO: ellipse formula here.
    C = x[0]*a*a + x[1]*a*b + x[2]*b*b + x[3]*a + x[4]*b - 1

    return a, b, C

"""# DO NOT MODIFY THE JUDGE CODE!!!"""

def judge_overlapping(points) :
    # calculate all sample point circle.
    A, b = circle(points)
    sol1 = np.linalg.lstsq(A, b, rcond=None)[0]
    x1 = sol1[0]
    y1 = sol1[1]
    r1 = math.sqrt(sol1[2]+x1**2+y1**2)

    sp = dataSampling(points)
    A, b = circle(sp)
    sol2 = np.linalg.lstsq(A, b, rcond=None)[0]
    x2 = sol2[0]
    y2 = sol2[1]
    r2 = math.sqrt(sol2[2]+x2**2+y2**2)

    d = math.sqrt((x1-x2)**2 + (y1-y2)**2)

    if r1+r2 <= d :
        # 1 point or no point
        return 0
    elif min(r1, r2) + d <= max(r1, r2) :
        # inner circle
        return (min(r1, r2)**2) / (max(r1, r2)**2)
   
    alpha = math.acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))
    beta = math.acos((r2**2 + d**2 - r1**2) / (2 * r2 * d))

    overlapping = alpha * (r1**2) + beta * (r2**2) - (r1**2) * math.cos(alpha) * math.sin(alpha) - (r2**2) * math.cos(beta) * math.sin(beta)

    return overlapping / (max(r1**2, r2**2) * np.pi)

def judge_sampling(points) :
    old_points = list(points)
    all_point = len(points)
    sp = dataSampling(points)
    sp_len = 0
    for p in sp :
        for ss in old_points :
            if ss[0] == p[0] and ss[1] == p[1] :
                sp_len += 1
    
    if (old_points != points) :
        return 0

    return (all_point - sp_len) / all_point


def judge(points) :
    sample = judge_sampling(points)
    overlap = judge_overlapping(points)

    print("The score of this question is : ")
    print("20 * (0.3 * ? (Efficiency, need your report) + 0.3 * {:f} (correctness) + 0.4 * {:f} (sampling) ) =  ? + {:f}".format(overlap, sample, 20 * (0.3 * overlap + 0.4 * sample)))

def main(file, mode="circle") :
    # read image and get circle points
    #im1 = img.imread('case1.png')
    im1 = img.imread(file)
    [h, w,c] = np.array(im1).shape
    points = [];
    for i in range(h):
        for j in range(w):
            if (all(im1[i,j,:])==0):
                points.append([i, j])


    # sampling data
    sp = dataSampling(points)

    if mode == "circle":
        # create matrix for fitting
        A, b = circle(sp)
        # solve the least square problem
        # print("np.linalg.lstsq")
        [x, r, rank] = np.linalg.lstsq(A, b, rcond=None)[0:3]
        print("Circle Rank: "+str(rank))
        #print("sum:" +str(r))

        a, b, C = draw_circle(x, h, w)

    elif mode == "ellipse":
        # create matrix for fitting
        A, b = ellipse(sp)

        # solve the least square problem
        [x, r, rank] = np.linalg.lstsq(np.dot(A.T, A), np.dot(A.T, b), rcond=None)[0:3]

        print("Ellipse Rank: "+str(rank))
        a, b, C = draw_ellipse(x, h, w)

    elif mode == "normal_equation":
        A, b = circle(sp)
        # solve the least square problem
        [x, r, rank] = normal_eq(A,b)[0:3]
        # print("Normal Equation")
        print("Circle Rank: "+str(rank))
        #print("sum:" +str(r))

        a, b, C = draw_circle(x, h, w)

    figure, axes = plt.subplots(1)
    plt.imshow(im1) 
    axes.contour(b, a, C, [0])
    axes.set_aspect(1)
    plt.savefig(file+'.output.png')
    plt.show()
    points = [];
    for i in range(h):
        for j in range(w):
            if (all(im1[i,j,:])==0):
                points.append([i, j])
    judge(points)
    print("="*50)

files = ['case1.png', 'case2.png', 'case3.png']
#for f in files :
#    main('/content/drive/My Drive/' + f, mode="circle")
#    main('/content/drive/My Drive/' + f, mode="ellipse")

# main('/content/drive/My Drive/'+ 'circle' + '.png', mode="circle")
# main('/content/drive/My Drive/'+ 'circle' + '.png', mode="ellipse")

# main('/content/drive/My Drive/'+ 'puddle' + '.png', mode="circle")
# main('/content/drive/My Drive/'+ 'puddle' + '.png', mode="ellipse")

start = 1
end   = 5
filename = 'case'
for i in range (start, end+1): 
  main('/content/drive/My Drive/'+ filename + str(i) + '.png', mode="circle")
  main('/content/drive/My Drive/'+ filename + str(i) + '.png', mode="ellipse")
 
filename = 'e'
print("1 ",end='') 
main('/content/drive/My Drive/'+ filename +  '1.png', mode="ellipse")
print("4 ",end='') 
main('/content/drive/My Drive/'+ filename +  '4.png', mode="ellipse")
print("9 ",end='') 
main('/content/drive/My Drive/'+ filename +  '9.png', mode="ellipse")

filename = 'c'
print("2 ",end='') 
main('/content/drive/My Drive/'+ filename + '2.png', mode="circle")
print("3 ",end='') 
main('/content/drive/My Drive/'+ filename + '3.png', mode="circle")
print("4 ",end='') 
main('/content/drive/My Drive/'+ filename + '4.png', mode="circle")


#c1 and c5 will cause linalg error bcs they are singular
# main('/content/drive/My Drive/' + 'c1.png', mode="normal_equation")
# main('/content/drive/My Drive/' + 'c2.png', mode="normal_equation")
# main('/content/drive/My Drive/' + 'c3.png', mode="normal_equation")
# main('/content/drive/My Drive/' + 'c4.png', mode="normal_equation")
# main('/content/drive/My Drive/' + 'c5.png', mode="normal_equation")
# main('/content/drive/My Drive/' + 'c6.png', mode="normal_equation")